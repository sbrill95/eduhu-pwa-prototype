# API Contract: Message Creation with Metadata

**Feature**: `003-agent-confirmation-ux`
**Purpose**: Document the updated message creation pattern with metadata field support for image messages and agent confirmations

## Overview

This contract defines how messages with metadata (especially image messages) are created in InstantDB to support:
1. Image thumbnails in chat history
2. Vision context for AI responses
3. Session persistence across agent workflows
4. Regeneration parameters for images

**Note**: This is NOT a new endpoint, but a contract for using the existing InstantDB message creation pattern with enhanced metadata.

## Message Creation Pattern

### Basic Message Structure (InstantDB)

```typescript
interface Message {
  id: string; // Generated by InstantDB
  content: string; // Message text
  role: 'user' | 'assistant' | 'system';
  timestamp: number; // Date.now()
  message_index: number; // Sequential index within session
  session: string; // Link to chat_sessions entity
  author: string; // Link to users entity
  metadata?: string; // JSON string (NEW: Enhanced structure)

  // Optional fields
  token_usage?: number;
  model_used?: string;
  processing_time?: number;
  is_edited: boolean;
  edited_at?: number;
}
```

---

## Contract 1: Creating Image Messages

**Purpose**: After image generation, create a message in chat history with image thumbnail and metadata.

### Frontend Code Pattern

```typescript
import db from '../lib/instantdb';
import type { MessageMetadata } from '../types/metadata';

/**
 * Create image message in chat after agent generates image
 */
const createImageMessage = async (params: {
  sessionId: string;
  userId: string;
  imageUrl: string;
  title: string;
  originalParams: {
    description: string;
    imageStyle: 'realistic' | 'cartoon' | 'illustrative' | 'abstract';
    learningGroup?: string;
    subject?: string;
  };
}) => {
  const { sessionId, userId, imageUrl, title, originalParams } = params;

  // 1. Get next message_index for session
  const messageIndex = await getNextMessageIndex(sessionId);

  // 2. Prepare metadata
  const metadata: MessageMetadata = {
    type: 'image',
    image_url: imageUrl,
    thumbnail_url: imageUrl, // Same URL, browser will scale
    title: title,
    originalParams: originalParams
  };

  // 3. Create message via InstantDB transaction
  const messageId = crypto.randomUUID();

  await db.transact(db.tx.messages[messageId].update({
    content: `Bild erstellt: ${title}`,
    role: 'assistant',
    timestamp: Date.now(),
    message_index: messageIndex,
    session: sessionId,
    author: userId,
    is_edited: false,
    metadata: JSON.stringify(metadata) // Store as JSON string
  }));

  console.log('[Message] Image message created:', messageId);
  return messageId;
};

/**
 * Helper: Get next message_index for session
 */
const getNextMessageIndex = async (sessionId: string): Promise<number> => {
  const { data } = await db.useQuery({
    messages: {
      $: {
        where: { 'session.id': sessionId },
        order: { message_index: 'desc' },
        limit: 1
      }
    }
  });

  const lastMessage = data?.messages?.[0];
  return (lastMessage?.message_index ?? -1) + 1;
};
```

### Expected Result

**InstantDB Record**:
```json
{
  "id": "abc123",
  "content": "Bild erstellt: Anatomischer Löwe - Seitenansicht",
  "role": "assistant",
  "timestamp": 1697123456789,
  "message_index": 12,
  "session": "session-xyz",
  "author": "user-456",
  "is_edited": false,
  "metadata": "{\"type\":\"image\",\"image_url\":\"https://api.instantdb.com/storage/xyz/lion.png\",\"thumbnail_url\":\"https://api.instantdb.com/storage/xyz/lion.png\",\"title\":\"Anatomischer Löwe - Seitenansicht\",\"originalParams\":{\"description\":\"Anatomischer Löwe für Biologieunterricht\",\"imageStyle\":\"realistic\",\"learningGroup\":\"Klasse 8a\",\"subject\":\"Biologie\"}}"
}
```

---

## Contract 2: Creating Agent Confirmation Messages

**Purpose**: When ChatGPT suggests using an agent, create a special message that renders as AgentConfirmationMessage component.

### Backend Code Pattern (Chat Route)

```typescript
import type { MessageMetadata } from '../types/metadata';

/**
 * When ChatGPT response contains agent suggestion
 */
const createAgentConfirmationMessage = async (params: {
  sessionId: string;
  userId: string;
  content: string; // Assistant's explanation text
  agentType: 'image-generation' | 'quiz-generator' | 'lesson-planner';
  reasoning: string; // Why the agent is recommended
  prefillData?: Record<string, any>; // Data to prefill agent form
}) => {
  const { sessionId, userId, content, agentType, reasoning, prefillData } = params;

  // 1. Get next message_index
  const messageIndex = await getNextMessageIndex(sessionId);

  // 2. Prepare metadata
  const metadata: MessageMetadata = {
    type: 'agent_confirmation',
    agentSuggestion: {
      agentType: agentType,
      reasoning: reasoning,
      prefillData: prefillData
    }
  };

  // 3. Create message
  const messageId = crypto.randomUUID();

  await db.transact(db.tx.messages[messageId].update({
    content: content,
    role: 'assistant',
    timestamp: Date.now(),
    message_index: messageIndex,
    session: sessionId,
    author: userId,
    is_edited: false,
    metadata: JSON.stringify(metadata)
  }));

  return messageId;
};
```

### Example Usage in Chat Endpoint

```typescript
// POST /api/chat
const handleChatMessage = async (req, res) => {
  const { message, sessionId, userId } = req.body;

  // 1. Send message to ChatGPT
  const response = await openai.chat.completions.create({
    model: 'gpt-4o',
    messages: buildMessagesArray(sessionId)
  });

  const assistantMessage = response.choices[0].message.content;

  // 2. Check if ChatGPT suggests an agent (via function calling or keywords)
  const agentSuggestion = detectAgentSuggestion(assistantMessage);

  if (agentSuggestion) {
    // Create agent confirmation message
    await createAgentConfirmationMessage({
      sessionId,
      userId,
      content: assistantMessage,
      agentType: agentSuggestion.agentType,
      reasoning: agentSuggestion.reasoning,
      prefillData: agentSuggestion.prefillData
    });
  } else {
    // Create normal text message
    await createTextMessage({
      sessionId,
      userId,
      content: assistantMessage
    });
  }

  res.json({ success: true });
};
```

---

## Contract 3: Session Persistence During Agent Workflow

**Purpose**: Ensure that messages created by agents are added to the EXISTING chat session, not a new one.

### Key Constraint

**MUST**: All messages related to a conversation MUST have the same `session` field value.

**MUST NOT**: Create a new chat_sessions entry when opening an agent modal.

### Implementation Checklist

**Step 1: Pass sessionId to AgentConfirmationMessage**
```tsx
// ChatView.tsx
<AgentConfirmationMessage
  message={message}
  sessionId={currentSessionId} // CRITICAL: Pass current session
/>
```

**Step 2: Pass sessionId to AgentContext**
```tsx
// AgentConfirmationMessage.tsx
const handleConfirm = () => {
  openModal(
    agentSuggestion.agentType,
    agentSuggestion.prefillData,
    sessionId // CRITICAL: Forward session ID
  );
};
```

**Step 3: Store sessionId in AgentContext State**
```typescript
// AgentContext.tsx
const [sessionId, setSessionId] = useState<string | undefined>();

const openModal = (agentType: string, prefillData: any, sessionId?: string) => {
  setSessionId(sessionId); // Store for later use
  setActiveAgent(agentType);
  setIsModalOpen(true);
};
```

**Step 4: Use sessionId When Creating Messages**
```typescript
// AgentFormView.tsx (inside image generation)
const { sessionId } = useAgent();

// After image generation
await createImageMessage({
  sessionId: sessionId!, // Use existing session
  userId: user.id,
  imageUrl: generatedImageUrl,
  title: formData.description,
  originalParams: formData
});
```

### Validation Query

**After agent workflow, verify session persistence**:
```typescript
const validateSessionPersistence = async (sessionId: string) => {
  const { data } = await db.useQuery({
    messages: {
      $: {
        where: { 'session.id': sessionId },
        order: { message_index: 'asc' }
      }
    }
  });

  // Check that message_index is sequential
  const indices = data?.messages.map(m => m.message_index) || [];
  const isSequential = indices.every((idx, i) => idx === i);

  if (!isSequential) {
    console.error('[Session] Message indices are NOT sequential:', indices);
  }

  return isSequential;
};
```

---

## Contract 4: Vision Context Integration

**Purpose**: When user asks about an image in chat, backend MUST send image to ChatGPT Vision API.

### Backend Pattern (Chat Route)

```typescript
/**
 * Build OpenAI messages array with vision support
 */
const buildMessagesForVision = async (sessionId: string) => {
  // 1. Fetch all messages from InstantDB
  const { data } = await db.useQuery({
    messages: {
      $: {
        where: { 'session.id': sessionId },
        order: { message_index: 'asc' }
      }
    }
  });

  // 2. Convert to OpenAI format
  const openAIMessages = data.messages.map(msg => {
    const metadata = msg.metadata ? JSON.parse(msg.metadata) : {};

    // Image message → Include vision content
    if (metadata.type === 'image' && metadata.image_url) {
      return {
        role: msg.role,
        content: [
          {
            type: 'text',
            text: msg.content || metadata.title || 'Generated image'
          },
          {
            type: 'image_url',
            image_url: {
              url: metadata.image_url,
              detail: 'low' // Cheaper, sufficient for context
            }
          }
        ]
      };
    }

    // Text message → Standard format
    return {
      role: msg.role,
      content: msg.content
    };
  });

  return openAIMessages;
};

/**
 * Send to OpenAI with vision support
 */
const response = await openai.chat.completions.create({
  model: 'gpt-4o', // MUST use vision-capable model
  messages: buildMessagesForVision(sessionId)
});
```

### Error Handling

**If image URL is expired (404)**:
```typescript
const buildMessagesForVision = async (sessionId: string) => {
  const messages = await fetchMessages(sessionId);

  return messages.map(msg => {
    const metadata = msg.metadata ? JSON.parse(msg.metadata) : {};

    if (metadata.type === 'image' && metadata.image_url) {
      // Check if image URL is still valid
      const isImageAvailable = await checkImageUrl(metadata.image_url);

      if (isImageAvailable) {
        // Include image in vision context
        return {
          role: msg.role,
          content: [
            { type: 'text', text: msg.content },
            { type: 'image_url', image_url: { url: metadata.image_url, detail: 'low' } }
          ]
        };
      } else {
        // Image expired → Send text-only with fallback message
        return {
          role: msg.role,
          content: `[Bild nicht mehr verfügbar: ${metadata.title}] ${msg.content}`
        };
      }
    }

    return { role: msg.role, content: msg.content };
  });
};
```

---

## Validation Tests

### Test 1: Image Message Appears in Chat History

**Setup**:
1. User asks: "Erstelle ein Bild von einem Löwen"
2. Agent generates image
3. `createImageMessage()` is called

**Verify**:
```typescript
const { data } = await db.useQuery({
  messages: {
    $: {
      where: { 'session.id': sessionId },
      order: { timestamp: 'desc' },
      limit: 1
    }
  }
});

const lastMessage = data.messages[0];
const metadata = JSON.parse(lastMessage.metadata);

assert(metadata.type === 'image');
assert(metadata.image_url.startsWith('https://api.instantdb.com/storage/'));
assert(metadata.title.includes('Löwe'));
assert(lastMessage.role === 'assistant');
```

### Test 2: Session ID Remains Constant

**Setup**:
1. Start chat with sessionId = "session-123"
2. User triggers image agent
3. Image is generated

**Verify**:
```typescript
const { data } = await db.useQuery({
  messages: {
    $: {
      where: { 'session.id': 'session-123' }
    }
  }
});

const sessionIds = data.messages.map(m => m.session);
const uniqueSessionIds = [...new Set(sessionIds)];

assert(uniqueSessionIds.length === 1); // All messages have same session
assert(uniqueSessionIds[0] === 'session-123'); // Session unchanged
```

### Test 3: Vision Context Works

**Setup**:
1. User generates image
2. User asks: "Was zeigt das Bild?"

**Verify**:
```typescript
// Backend should send messages array with vision content
const openAIMessages = buildMessagesForVision(sessionId);

const imageMessage = openAIMessages.find(m =>
  Array.isArray(m.content) &&
  m.content.some(c => c.type === 'image_url')
);

assert(imageMessage !== undefined); // Image included in context
assert(imageMessage.content[1].image_url.url.includes('storage'));
```

### Test 4: Message Index Sequential

**Setup**:
1. Chat has 10 messages (index 0-9)
2. User generates image (should be index 10)
3. User continues chatting (should be index 11, 12, ...)

**Verify**:
```typescript
const { data } = await db.useQuery({
  messages: {
    $: {
      where: { 'session.id': sessionId },
      order: { message_index: 'asc' }
    }
  }
});

const indices = data.messages.map(m => m.message_index);
const isSequential = indices.every((idx, i) => idx === i);

assert(isSequential); // No gaps in indices
```

---

## Error Scenarios

### Scenario 1: Metadata Parsing Fails

**Problem**: `JSON.parse(message.metadata)` throws error

**Solution**:
```typescript
const parseMetadata = (metadataString?: string): MessageMetadata => {
  if (!metadataString) return {};
  try {
    return JSON.parse(metadataString);
  } catch (error) {
    console.error('[Message] Failed to parse metadata:', error);
    return {}; // Graceful fallback
  }
};
```

### Scenario 2: sessionId is Undefined

**Problem**: `openModal()` called without sessionId

**Solution**:
```typescript
const createImageMessage = async (params: { sessionId?: string, ... }) => {
  if (!params.sessionId) {
    console.warn('[Message] No sessionId provided, creating new session');
    params.sessionId = await createNewChatSession(params.userId);
  }
  // Continue with creation
};
```

### Scenario 3: Duplicate message_index

**Problem**: Two messages get same index due to race condition

**Solution**:
```typescript
const getNextMessageIndex = async (sessionId: string): Promise<number> => {
  // Use InstantDB transaction to ensure atomic increment
  const result = await db.transact([
    db.tx.messages.query({
      where: { 'session.id': sessionId },
      order: { message_index: 'desc' },
      limit: 1
    })
  ]);

  const lastMessage = result.data.messages[0];
  return (lastMessage?.message_index ?? -1) + 1;
};
```

---

## Migration Path

**No breaking changes** - This is an enhancement of existing message creation:

1. **Old messages** (without metadata): Still work, treated as type='text'
2. **New messages** (with metadata): Use enhanced rendering (image thumbnails, etc.)
3. **Backward compatibility**: All existing chat queries continue to work

**No schema migration required** - metadata field already exists as optional string.

---

## References

- InstantDB Schema: `teacher-assistant/backend/src/schemas/instantdb.ts`
- Data Model: `specs/003-agent-confirmation-ux/data-model.md`
- Message Types: `teacher-assistant/frontend/src/types/metadata.ts`
- OpenAI Vision Docs: https://platform.openai.com/docs/guides/vision
