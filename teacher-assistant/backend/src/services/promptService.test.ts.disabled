/**
 * Unit Tests for PromptService
 *
 * Tests for the Home Screen Redesign feature - prompt generation service
 */

import { PromptService } from './promptService';
import { PROMPT_TEMPLATES } from '../data/promptTemplates';
import * as InstantDBService from './instantdbService';

// Mock the InstantDB service
jest.mock('./instantdbService');
jest.mock('../config/logger');

describe('PromptService', () => {
  let promptService: PromptService;

  beforeEach(() => {
    promptService = new PromptService();
    jest.clearAllMocks();

    // Mock isInstantDBAvailable to return false by default (use mock profile)
    (InstantDBService.isInstantDBAvailable as jest.Mock).mockReturnValue(false);
  });

  describe('generateSuggestions', () => {
    test('should return 6 prompts by default', async () => {
      const result = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 6,
      });

      expect(result).toHaveLength(6);
      expect(result[0]).toHaveProperty('id');
      expect(result[0]).toHaveProperty('title');
      expect(result[0]).toHaveProperty('description');
      expect(result[0]).toHaveProperty('prompt');
      expect(result[0]).toHaveProperty('category');
      expect(result[0]).toHaveProperty('icon');
      expect(result[0]).toHaveProperty('color');
      expect(result[0]).toHaveProperty('estimatedTime');
    });

    test('should respect custom limit parameter', async () => {
      const result = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 3,
      });

      expect(result).toHaveLength(3);
    });

    test('should personalize prompts with user profile data', async () => {
      const result = await promptService.generateSuggestions({
        userId: 'test-user-123',
      });

      // Check that placeholders are replaced
      result.forEach((suggestion) => {
        expect(suggestion.prompt).not.toContain('{{fach}}');
        expect(suggestion.prompt).not.toContain('{{klassenstufe}}');
        expect(suggestion.title).not.toContain('{{fach}}');
        expect(suggestion.description).not.toContain('{{klassenstufe}}');
      });

      // Check that mock profile data is used (Mathematik, 7. Klasse)
      const hasExpectedSubject = result.some((s) =>
        s.prompt.includes('Mathematik')
      );
      const hasExpectedGrade = result.some((s) => s.prompt.includes('7'));
      expect(hasExpectedSubject).toBe(true);
      expect(hasExpectedGrade).toBe(true);
    });

    test('should include metadata with templateId and personalized flag', async () => {
      const result = await promptService.generateSuggestions({
        userId: 'test-user-123',
      });

      result.forEach((suggestion) => {
        expect(suggestion.metadata).toBeDefined();
        expect(suggestion.metadata?.templateId).toBeDefined();
        expect(suggestion.metadata?.personalized).toBe(true);
      });
    });

    test('should use fallback profile when user profile not found', async () => {
      // Mock InstantDB as available but return null profile
      (InstantDBService.isInstantDBAvailable as jest.Mock).mockReturnValue(
        true
      );
      (
        InstantDBService.TeacherProfileService.getTeacherProfile as jest.Mock
      ).mockResolvedValue(null);

      // Should not throw error, but use fallback data
      const suggestions = await promptService.generateSuggestions({
        userId: 'non-existent-user',
        limit: 3,
      });

      // Verify suggestions are returned with fallback data
      expect(suggestions).toBeDefined();
      expect(suggestions.length).toBe(3);

      // Verify fallback data is used (Mathematik, 7. Klasse, Gymnasium)
      suggestions.forEach((suggestion) => {
        expect(suggestion.prompt).toContain('Mathematik');
        expect(suggestion.metadata?.personalized).toBe(true);
      });
    });

    test('should exclude templates with matching excludeIds', async () => {
      // First, generate suggestions to get template IDs
      const firstResult = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 6,
      });

      // Extract template IDs from first result
      const excludeIds = firstResult
        .slice(0, 3)
        .map((s) => s.metadata?.templateId || '');

      // Generate new suggestions excluding those template IDs
      const secondResult = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 6,
        excludeIds,
      });

      // Verify that none of the excluded templates are in the second result
      secondResult.forEach((suggestion) => {
        expect(excludeIds).not.toContain(suggestion.metadata?.templateId);
      });
    });
  });

  describe('seededShuffle', () => {
    test('should produce same order with same seed', async () => {
      const seed = '2025-10-01';

      const result1 = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 6,
        seed,
      });

      const result2 = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 6,
        seed,
      });

      // Compare template IDs to verify same order
      const templateIds1 = result1.map((s) => s.metadata?.templateId);
      const templateIds2 = result2.map((s) => s.metadata?.templateId);

      expect(templateIds1).toEqual(templateIds2);
    });

    test('should produce different order with different seeds', async () => {
      const result1 = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 6,
        seed: '2025-10-01',
      });

      const result2 = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 6,
        seed: '2025-10-02',
      });

      // Compare template IDs - they should be different
      const templateIds1 = result1.map((s) => s.metadata?.templateId);
      const templateIds2 = result2.map((s) => s.metadata?.templateId);

      // At least one template should be different (very high probability)
      const hasDifference = templateIds1.some(
        (id, index) => id !== templateIds2[index]
      );
      expect(hasDifference).toBe(true);
    });
  });

  describe('weighted randomization', () => {
    test('should prioritize templates with higher weight', async () => {
      // Run multiple times and count how often high-weight templates appear
      const iterations = 50;
      const templateCounts: Record<string, number> = {};

      for (let i = 0; i < iterations; i++) {
        const result = await promptService.generateSuggestions({
          userId: 'test-user-123',
          limit: 6,
          seed: `seed-${i}`, // Different seed each time
        });

        result.forEach((suggestion) => {
          const templateId = suggestion.metadata?.templateId || '';
          templateCounts[templateId] = (templateCounts[templateId] || 0) + 1;
        });
      }

      // Find high-weight and low-weight templates
      const highWeightTemplate = PROMPT_TEMPLATES.find((t) => t.weight === 10);
      const lowWeightTemplate = PROMPT_TEMPLATES.find((t) => t.weight <= 5);

      if (highWeightTemplate && lowWeightTemplate) {
        const highWeightCount = templateCounts[highWeightTemplate.id] || 0;
        const lowWeightCount = templateCounts[lowWeightTemplate.id] || 0;

        // High-weight templates should appear more frequently
        expect(highWeightCount).toBeGreaterThan(lowWeightCount);
      }
    });
  });

  describe('fallback topic generation', () => {
    test('should generate appropriate topics for different subjects', async () => {
      // Test with InstantDB mock providing different subjects
      (InstantDBService.isInstantDBAvailable as jest.Mock).mockReturnValue(
        true
      );

      // Test Mathematik
      (
        InstantDBService.TeacherProfileService.getTeacherProfile as jest.Mock
      ).mockResolvedValue({
        subjects: ['Mathematik'],
        grades: ['7'],
        school_type: 'Gymnasium',
        teaching_methods: [],
        topics: [],
        challenges: [],
      });

      const mathResult = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 3,
      });

      const hasMathTopics = mathResult.some(
        (s) =>
          s.prompt.includes('Bruchrechnung') ||
          s.prompt.includes('Geometrie') ||
          s.prompt.includes('Algebra')
      );
      expect(hasMathTopics).toBe(true);

      // Test Deutsch
      (
        InstantDBService.TeacherProfileService.getTeacherProfile as jest.Mock
      ).mockResolvedValue({
        subjects: ['Deutsch'],
        grades: ['7'],
        school_type: 'Gymnasium',
        teaching_methods: [],
        topics: [],
        challenges: [],
      });

      const germanResult = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 3,
      });

      const hasGermanTopics = germanResult.some(
        (s) =>
          s.prompt.includes('Grammatik') ||
          s.prompt.includes('Aufsatz') ||
          s.prompt.includes('Literaturanalyse')
      );
      expect(hasGermanTopics).toBe(true);
    });

    test('should use user topics if available', async () => {
      (InstantDBService.isInstantDBAvailable as jest.Mock).mockReturnValue(
        true
      );
      (
        InstantDBService.TeacherProfileService.getTeacherProfile as jest.Mock
      ).mockResolvedValue({
        subjects: ['Mathematik'],
        grades: ['7'],
        school_type: 'Gymnasium',
        teaching_methods: [],
        topics: ['Quadratische Gleichungen', 'Pythagoras'],
        challenges: [],
      });

      const result = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 6,
      });

      const hasUserTopics = result.some(
        (s) =>
          s.prompt.includes('Quadratische Gleichungen') ||
          s.prompt.includes('Pythagoras')
      );
      expect(hasUserTopics).toBe(true);
    });
  });

  describe('template filtering', () => {
    test('should only include templates for which user has required context', async () => {
      (InstantDBService.isInstantDBAvailable as jest.Mock).mockReturnValue(
        true
      );

      // Mock profile with only subjects, no grades
      (
        InstantDBService.TeacherProfileService.getTeacherProfile as jest.Mock
      ).mockResolvedValue({
        subjects: ['Mathematik'],
        grades: [],
        school_type: null,
        teaching_methods: [],
        topics: [],
        challenges: [],
      });

      const result = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 6,
      });

      // Should get fallback suggestions since no templates match (most require both fach and klassenstufe)
      expect(result.length).toBeGreaterThan(0);
      result.forEach((suggestion) => {
        expect(suggestion).toHaveProperty('id');
        expect(suggestion).toHaveProperty('category');
      });
    });
  });

  describe('unique ID generation', () => {
    test('should generate unique IDs for each suggestion', async () => {
      const result = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 6,
      });

      const ids = result.map((s) => s.id);
      const uniqueIds = new Set(ids);

      expect(uniqueIds.size).toBe(ids.length);
    });
  });

  describe('category distribution', () => {
    test('should include suggestions from multiple categories', async () => {
      const result = await promptService.generateSuggestions({
        userId: 'test-user-123',
        limit: 6,
      });

      const categories = result.map((s) => s.category);
      const uniqueCategories = new Set(categories);

      // Should have at least 2 different categories
      expect(uniqueCategories.size).toBeGreaterThanOrEqual(2);
    });
  });
});
